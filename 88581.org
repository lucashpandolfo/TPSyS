#+LATEX_HEADER: \usepackage{pst-sigsys}
#+LATEX_HEADER: \usepackage{auto-pst-pdf}
#+LATEX_HEADER: \pagestyle{fancy}
#+LATEX_HEADER: \setlength{\parskip}{0cm}
#+LATEX_HEADER: \parindent=0cm
#+TITLE: 
#+OPTIONS:  toc:nil
#+LATEX_HEADER: \lhead{\includegraphics[width=1.5cm]{img/Logo-fiuba}} \chead{66.74  - Señales y Sistemas} \rhead{\Huge FIUBA}
#+LATEX_HEADER: \lfoot{88581 - Pandolfo Lucas} \cfoot{\thepage} \rfoot{$2^{do}$ cuatrimestre 2011}

* Principios básicos
** Ejercicio 1
   #+LABEL: fig-r-rangos
   #+CAPTION: \gamma-rangos
   #+ATTR_LaTeX: width=0.6\columnwidth placement=[H]
   [[file:img/r-rangos.pdf]]

#+BEGIN_LATEX
  \begin{eqnarray*}
    R_n &=& sen(\eta_n) r_n \\
    \\
    \Delta R_n &=& R_n - R_{n-1} \\
    \Delta R_n &=&  sen(\eta_n) r_n -  sen(\eta_{n-1}) r_{n-1} \\
    \\
    \\ r_k &=& \frac{k c T_s}{2}\\
    \gamma-rango_k = r_k &=& \frac{h}{cos(\eta_k)}\\
    \\
    \eta_k &=& cos^{-1}\left(\frac{h}{r_k}\right)
  \end{eqnarray*}  
#+END_LATEX

   Para poder graficar $\eta_k$ y $\Delta R_k$, necesitamos primero
   calular $r_o$. Sabiendo que:

#+BEGIN_LATEX
  \begin{eqnarray*}
    Fs &=& 50\, 10^6\\
    Ts &=& \frac{1}{Fs} = 50\, 10^{-6}\\
    h  &=& 5375 m\\
    \eta_0 &=& \eta_{near} = 18.24° \\
    c &=& 299.792.458 \frac{m}{s}  
  \end{eqnarray*}
#+END_LATEX

   Podemos calcular $r_0$ como $\frac{h}{cos(\eta_0)}$ que resulta
   en $$r_0 \approx 5659$$

    #+LABEL: fig-eta-vs-rango
    #+CAPTION: $\eta$ en función del rango $r_k$
    #+ATTR_LaTeX: width=0.6\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  h = 5375;
  n_near = 18.24*pi/180;
  c = 299792458;
  Ts = 50e-6;
  kmax = 20;
  r0 = h/(cos(n_near));
  rangos = r0:c*Ts/2:r0+kmax*c*Ts/2;
  plot(0:kmax,acos(h./rangos)*180/pi, 'linewidth', 4);
  set(gca, 'interpreter', 'tex');
  set(gca, 'ytick', 15:5:90);
  axis([0 kmax 15 90]);
  set(gca, 'xtick', 0:kmax);
  cambiarEjeY("%0.0f^o",1);
  cambiarEjeX("r_{%d}",1);
  grid();
  ans = guardarImagen("img/eta-vs-rango.pdf");
#+end_src
#+results:
   [[file:img/eta-vs-rango.pdf]]

    #+LABEL: fig-deltar-vs-rango
    #+CAPTION: $\Delta R$ en función del rango $r_k$
    #+ATTR_LaTeX: width=0.6\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  h = 5375;
  n_near = 18.24*pi/180;
  c = 299792458;
  Ts = 50e-6;
  kmax = 20;
  r0 = h/(cos(n_near));
  rangos = r0:c*Ts/2:r0+kmax*c*Ts/2;
  etas = acos(h./rangos);
  
  deltas = sin(etas).*rangos-shift(sin(etas).*rangos,1)
  plot(deltas(2:end), 'linewidth', 4);
  axis([1 length(deltas)-1])
  set(gca, 'interpreter', 'tex');
  set(gca, 'xtick', 1:length(deltas)-1);
  cambiarEjeX("r_{%d}",1);

  grid();
  ans = guardarImagen("img/deltaR-vs-rango.pdf");
#+end_src
#+results:
   [[file:img/deltaR-vs-rango.pdf]]
   
\newpage

* Parte analógica
** Ejercicio 2

   La señal chirp se define como

   $$chirp(t) = e^{j\theta(t)}$$

   donde $\theta(t)$ es una función cuadrática del tiempo con forma

   $$\theta(t) = k_1 t^2 + k_2 t$$

   La frecuencia instantánea de la chirp es entonces:

   $$f\_inst(t) = 2 k_1 t + k_2$$

   Como la chirp barre frecuencias que van desde -20Mhz hasta 20Mhz en
   10$\mu s$:

   $$f\_inst(0) = 2 k_1 0 + k_2 = k2 = -20 Mhz$$

   Y al final

#+BEGIN_LATEX
  \begin{eqnarray*}
    f\_inst(10\mu s) = 2 k_1 10\mu s + k_2 &=& 20 Mhz \\
                       2 k_1 10\mu s - 20Mhz &=& 20 Mhz \\
                       k_1 &=& \frac{40Mhz}{2\, 10\mu s}\\
                       k_1 = 2\,\,10^{12}
  \end{eqnarray*}
#+END_LATEX

   Por lo tanto, la fase instantánea es

   $$f\_inst(t) =  4 \times 10^{12} t^2 - 20 \times 10^6 t$$

   En la figura \ref{fig-chirp-no-modulada} se puede ver el resultado
   de graficar las partes real e imaginarias de la chirp junto con la
   fase instantánea en función del tiempo. \\

   La chirp tiene una frecuencia máxima de 20Mhz y por Nyquist la
   mínima frecuencia de muestreo que podemos usar es 40Mhz, si no se
   satisface el criterio de Nyquist se producen resultados como el de
   la figura \ref{fig-chirp-no-modulada-no-nyquist}.

    #+LABEL: fig-chirp-no-modulada
    #+CAPTION: Chirp emitida por el SARAT (no modulada)
    #+ATTR_LaTeX: angle=-90,width=0.9\columnwidth placement=[p]
#+begin_src octave :exports results :results file
  t = 0:1/Fs:10e-6
  chirp_nm = chirp_no_modulada(t);
  subplot(311);
  plot(t,real(chirp_nm), "linewidth", 3);
  title("Parte real");
  axis([0 t(end)])
  cambiarEjeX("%.00fus",1e6);
  subplot(312);
  plot(t,imag(chirp_nm), "linewidth", 3);
  title("Parte imaginaria");
  axis([0 t(end)])
  cambiarEjeX("%.00fus",1e6);
  subplot(313);
  plot(t,arg(chirp_nm), "linewidth", 3);
  title("Fase");
  axis([0 t(end) -pi pi])
  cambiarEjeX("%.00fus",1e6);
  set(gca, 'ytick', [-pi -pi/2 0 pi/2 pi])
  set(gca, 'interpreter', 'tex');
  set(gca,'YTickLabel',{'-\pi' '-\pi/2' '0' '\pi/2' '\pi'}, 'interpreter', 'tex');
  ans = guardarImagen("img/chirp-no-modulada.pdf");
#+end_src
#+results:
   [[file:img/chirp-no-modulada.pdf]]


    #+LABEL: fig-chirp-no-modulada-no-nyquist
    #+CAPTION: Chirp emitida por el SARAT (no modulada) submuestreada
    #+ATTR_LaTeX: angle=-90,width=0.9\columnwidth placement=[p]
#+begin_src octave :exports results :results file
  t = 0:1/(Fs/2):10e-6
  chirp_nm = chirp_no_modulada(t);
  subplot(311);
  plot(t,real(chirp_nm), "linewidth", 3);
  title("Parte real");
  axis([0 t(end)])
  cambiarEjeX("%.00fus",1e6);
  subplot(312);
  plot(t,imag(chirp_nm), "linewidth", 3);
  title("Parte imaginaria");
  axis([0 t(end)])
  cambiarEjeX("%.00fus",1e6);
  subplot(313);
  plot(t,arg(chirp_nm), "linewidth", 3);
  title("Fase");
  axis([0 t(end) -pi pi])
  cambiarEjeX("%.00fus",1e6);
  set(gca, 'ytick', [-pi -pi/2 0 pi/2 pi])
  set(gca, 'interpreter', 'tex');
  set(gca,'YTickLabel',{'-\pi' '-\pi/2' '0' '\pi/2' '\pi'}, 'interpreter', 'tex');
  ans = guardarImagen("img/chirp-no-modulada-submuestreada.pdf");
#+end_src
#+results:
   [[file:img/chirp-no-modulada-submuestreada.pdf]]

    #+LABEL: fig-espectro-chirp-no-modulada
    #+CAPTION: Espectro de la  Chirp emitida por el SARAT (no modulada)
    #+ATTR_LaTeX: width=0.9\columnwidth placement=[p]
#+begin_src octave :exports results :results file
  t = 0:1/(Fs):10e-6
  chirp_nm = chirp_no_modulada(t);
  espectro = fftshift(abs(fft(chirp_nm)));
  plot(Fs/t(end) * t -Fs/2,10*log10(espectro), "linewidth", 3);
  axis([-Fs/2 Fs/2 0 15])
  cambiarEjeX("%0.0fMhz", 1/1e6);
  cambiarEjeY("%ddB", 1);
  grid();
  ans = guardarImagen("img/espectro-chirp-no-modulada.pdf");
#+end_src
#+results:
   [[file:img/espectro-chirp-no-modulada.pdf]]


** Ejercicio 3

    #+LABEL: fig-chirp-no-modulada-espectrograma
    #+CAPTION: Espectrograma de la Chirp emitida por el SARAT (no modulada)
    #+ATTR_LaTeX: width=0.6\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  t = 0:1/Fs:10e-6*10;
  chirp_nm = real(chirp_no_modulada(t))
  specgram(chirp_nm,[],Fs,hann(50),40);
  cambiarEjeY("%0.0fMhz", 1e-6);
  cambiarEjeX("%0.0fus", 1e6);
  ans = guardarImagen("img/chirp-no-modulada-espectro.pdf");
#+end_src
#+results:
   [[file:img/chirp-no-modulada-espectro.pdf]]

    #+LABEL: fig-chirp-no-modulada-espectrograma-submuestreada
    #+CAPTION: Espectrograma de la Chirp emitida por el SARAT (no modulada) submuestreada
    #+ATTR_LaTeX: width=0.6\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  t = 0:1/(Fs/2):10e-6*10;
  chirp_nm = real(chirp_no_modulada(t))
  specgram(chirp_nm,[],Fs/2,hann(50),40);
  cambiarEjeY("%0.0fMhz", 1e-6);
  cambiarEjeX("%0.0fus", 1e6);
  ans = guardarImagen("img/chirp-no-modulada-espectro-submuestreada.pdf");
#+end_src
#+results:
   [[file:img/chirp-no-modulada-espectro-submuestreada.pdf]]

   Para realizar los espectrogramas se utilizó una ventana de hann de
   largo 50 y un solapamiento de 40 muestras. Como la frecuencia de
   muestreo es de 50Mhz, el aliasing se puede observar cuando la
   frecuencia de la chirp sobrepasa los 25Mhz, es en este momento
   cuando la frecuencia de la chirp parece estar disminuyendo y cae
   hasta cero para luego volver a crecer hasta los 25Mhz. \\

   El uso de diferentes tipos de ventana altera los contenidos de
   frecuencia de la señal original. En las figura
   \ref{fig-comparacion-ventanas} se muestra una comparación de
   aplicar diferentes tipos de ventanas a las primeras 100 muestras de
   la chirp generada en puntos anteriores y en la figura
   \ref{fig-comparacion-ventanas2} se muestran los resultados de
   utilizar cada una de estas ventanas al espectrograma.  \\

   Por último en la figura \ref{fig-comparacion-solapamiento} se
   muestra el efecto de utilizar diferentes solapamientos. Cuanto mas
   se solapan las ventanas, mayor resolución se obtiene para un
   instante dado. Notar que en los casos de bajo solapamiento para
   toda una franja de tiempo se tiene los mismos componentes de
   frecuencia, mientras que en los de alto solapamiento esta franja de
   tiempo se hace muy pequeña.


    #+LABEL: fig-comparacion-ventanas
    #+CAPTION: Comparación de diferentes tipos de ventanas
    #+ATTR_LaTeX: angle=-90,width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  t = 0:1/(Fs):10e-6*10;
  chirp_nm = real(chirp_no_modulada(t))
  longitud = 100;
  inicio = 1;
  chirp_window = chirp_nm(inicio:inicio+longitud-1);
  ventanas{1} = {rectwin(longitud), "Rectangular"};
  ventanas{2} = {tukeywin(longitud), "Tukey"};
  ventanas{3} = {hann(longitud), "Hann"};
  ventanas{4} = {bartlett(longitud), "Bartlett"};
  
  max = length(ventanas);
  for i = 1:max
    subplot(max,2,2*i-1)
    plot(ventanas{i}{1}, 'linewidth', 3);
    title(ventanas{i}{2});
    subplot(max,2,2*i)
    plot((-longitud/2+1:longitud/2) ,abs(fftshift(fft(ventanas{i}{1}.'.*chirp_window))),'linewidth', 3);
    cambiarEjeX("%0.0fMhz",Fs*2/longitud * 1e-6);
    grid();
  end
  ans = guardarImagen("img/comparacion-ventanas.pdf");
#+end_src
#+results:
   [[file:img/comparacion-ventanas.pdf]]

    #+LABEL: fig-comparacion-ventanas2
    #+CAPTION: Comparación de diferentes tipos de ventanas (espectrogramas)
    #+ATTR_LaTeX: angle=-90,width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  t = 0:1/(Fs):10e-6*10;
  chirp_nm = real(chirp_no_modulada(t))
  longitud = 50;
  solapamiento= 25;
  inicio = 20;
  chirp_window = chirp_nm(inicio:inicio+longitud-1);
  ventanas{1} = {rectwin(longitud), "Rectangular"};
  ventanas{2} = {tukeywin(longitud), "Tukey"};
  ventanas{3} = {hann(longitud), "Hann"};
  ventanas{4} = {bartlett(longitud), "Bartlett"};
  
  max = length(ventanas);
  for i = 1:max
    subplot(max/2,2,i)
    specgram(chirp_nm,[],Fs,ventanas{i}{1},solapamiento);
    cambiarEjeY("%0.0fMhz", 1e-6);
    cambiarEjeX("%0.0fus", 1e6);
    title(ventanas{i}{2});
  end
  
  ans = guardarImagen("img/comparacion-ventanas2.pdf");
#+end_src
#+results:
   [[file:img/comparacion-ventanas2.pdf]]


    #+LABEL: fig-comparacion-solapamiento
    #+CAPTION: Comparación de diferentes solapamientos para una ventana de Hann 50 muestras (espectrogramas)
    #+ATTR_LaTeX: angle=-90,width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  t = 0:1/(Fs):10e-6*10;
  chirp_nm = real(chirp_no_modulada(t))
  longitud = 50;
  inicio = 20;
  chirp_window = chirp_nm(inicio:inicio+longitud-1);
  solapamiento{1} = {0, "Sin solapamiento"};
  solapamiento{2} = {15, "15 muestras"};
  solapamiento{3} = {30, "30 muestras"};
  solapamiento{4} = {49, "49 muestras"};
  
  max = length(solapamiento);
  for i = 1:max
    subplot(max/2,2,i)
    specgram(chirp_nm,[],Fs,hann(longitud),solapamiento{i}{1});
    cambiarEjeY("%0.0fMhz", 1e-6);
    cambiarEjeX("%0.0fus", 1e6);
    title(solapamiento{i}{2});
  end
  
  ans = guardarImagen("img/comparacion-solapamientos.pdf");
#+end_src
#+results:
   [[file:img/comparacion-solapamientos.pdf]]


** Ejercicio 4

   La chirp está definida como:

   $$chirp(t) = e^{j \phi(t)}$$

   Donde $\phi(t)$ es la fase en función del tiempo.Como ya se mostró
   en el punto 2, la frecuencia instantánea
   $\left(\frac{\partial\phi}{\partial t}\right)$ de la chirp (figura
   \ref{fig-chirp-frecuencia-instantanea}) es

   $$f\_inst(t) = 2 k_1 t + k_2$$

   Donde $k_2$ es la frecuencia inicial y $2 k_1$ es el incremento de
   frecuencia por unidad de tiempo. Se ve entonces que $f\_inst(t)$ es
   una función lineal del tiempo con $2 k_1$ como la pendiente.

   #+LABEL: fig-chirp-frecuencia-instantanea
   #+CAPTION: Frecuencia instantánea de la chirp
   #+ATTR_LaTeX: width=0.6\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  t = 0:1/Fs:10e-6;
  plot(t,4e12*t-20e6, 'linewidth', 5);
  axis([0 t(end)]);
  cambiarEjeX("%0.0fus", 1e6);
  cambiarEjeY("%0.0fMhz", 1/1e6);
  grid();
  ans = guardarImagen("img/chirp-frecuencia-instantanea.pdf");
#+end_src
#+results:
[[file:img/chirp-frecuencia-instantanea.pdf]]


** Ejercicio 5

#+BEGIN_LATEX
  \begin{figure}[ht]
    \centering %
    \begin{pspicture}[showgrid=false](0,0)(10,5)
      
      \psset{style = RoundCorners , style = Arrow , linecolor=blue, FillColor=blue!20}
      
      \fnode[style=Dash,linecolor=blue,framesize=6 4, fillstyle=none](3,2){generador}
      \nput{90}{generador}{Generador de Chirp}
      
      \psblock(1,1){chirp}{$Chirp$}
      
      \pscircleop[operation=times](3,1){prod1}
      
      \psblock(5,1){real}{$\it Re (\bullet)$}
  
      \pscircleop[operation=times](7,1){prod2}
  
      \psblock(9,1){bp}{$BP$}
  
      \pssignal(10,1){fin}{$E$}
  
      \psblock(3,3){exp}{$e^{(j\omega_0 t)}$}
  
      \psblock(7,3){modulador}{$Cos(\omega_1 t)$}
      \nput{90}{Modulador}
  
      \nclist{ncline}[naput]{chirp,prod1 $A$,real $B$,prod2 $C$,bp $D$,fin}
  
      \ncline{exp}{prod1}
  
      \ncline{modulador}{prod2}
      
    \end{pspicture}
  \end{figure}
  
#+END_LATEX

   #+LABEL: fig-espectros-modulador-ideal
   #+CAPTION: Espectro de las señales en las diferentes fases del modulador
   #+ATTR_LaTeX: width=0.7\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  
  MPM = 2; 
  
  subplot(511);
  original = [zeros(1,10*MPM) bartlett(50*MPM).' zeros(1,10*MPM)];
  plot(-length(original)/2+1:length(original)/2, original, 'linewidth', 4);
  legend('A');
  axis([-length(original)/2+1 length(original)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();
  
  subplot(512);
  desplazado = [zeros(1,(175+50+20)*MPM) zeros(1,175*MPM) bartlett(50*MPM).' zeros(1,20*MPM)];
  plot(-length(desplazado)/2+1:length(desplazado)/2, desplazado, 'linewidth', 4);
  legend('B');
  axis([-length(desplazado)/2+1 length(desplazado)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();
  
  subplot(513);
  parteReal = [zeros(1,20*MPM) bartlett(50*MPM).' zeros(1,175*MPM) zeros(1,175*MPM) bartlett(50*MPM).' zeros(1,20*MPM)];
  plot(-length(parteReal)/2+1:length(parteReal)/2, parteReal, 'linewidth', 4);
  legend('C');
  axis([-length(parteReal)/2+1 length(parteReal)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();
  
  
  subplot(514);
  redesplazado = [zeros(1,1100*MPM - length(parteReal)/2) parteReal];
  redesplazado = [redesplazado(end:-1:1) redesplazado]
  plot(-length(redesplazado)/2+1:length(redesplazado)/2, redesplazado, 'linewidth', 4);
  legend('D');
  axis([-length(redesplazado)/2+1 length(redesplazado)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();
  
  subplot(515);
  filtro = ones(1,length(redesplazado));
  filtro(80*MPM:end-80*MPM)=0;
  filtrado = redesplazado .* filtro;
  plot(-length(filtrado)/2+1:length(filtrado)/2, filtrado, 'linewidth', 4);
  legend('E');
  axis([-length(filtrado)/2+1 length(filtrado)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();
  
  
  ans = guardarImagenOctave("img/espectros-modulador-ideal.pdf");
#+end_src
#+results:
   [[file:img/espectros-modulador-ideal.pdf]]


** Ejercicio 6


#+BEGIN_LATEX
  \begin{figure}[H]
    \centering %
    \begin{pspicture}[showgrid=false](-1,-5)(11,4)
      
      \psset{style = RoundCorners , style = Arrow , linecolor=blue, FillColor=blue!20}

      \pssignal(0,1){inicio}{}

      \psblock(2,1){bp}{$BP$}
      
      \pscircleop[operation=times](4,1){prod1}
      
      \psblock(6,1){bp2}{$BP$}

      \pssignal(9,1){salida1}{Señal en FI}

      \psblock(4,3){cos1}{$Cos(\omega_1 t)$}
         \nput{90}{Demodulador 1}
  
      \nclist{ncline}[naput]{inicio,bp,prod1 $A$,bp2 $B$,salida1 $C$}
  
      \ncline{cos1}{prod1}


      \pssignal(-1,-3){inicio2}{Señal en FI}

      \dotnode(1,-3){dot}    

      \pscircleop[operation=times](2,-2){prod2}
      \psblock(5,-2){lp1}{$LP$}
      \psblock(7,-2){ad1}{$A/D$}
      \pssignal(9,-2){salida2}{}

      \pszero[zeroradius=0.4](3.5,-3){p1}
         \nput{0}{p1}{$e^{-j\omega_0 t}$}

      \pscircleop[operation=times](2,-4){prod3}
      \psblock(5,-4){lp2}{$LP$}
      \psblock(7,-4){ad2}{$A/D$}
      \pssignal(9,-4){salida3}{}

      
      \ncline{-}{inicio2}{dot}
      \ncangle[angleA=90,angleB=180,fillstyle=none]{dot}{prod2}
      \ncangle[angleA=-90,angleB=180,fillstyle=none]{dot}{prod3}

      \ncangle[angleA=180,angleB=-90,fillstyle=none,offsetA=-0.2,offsetB=0]{p1}{prod2}
      \nbput[npos=0.5]{$\it Re(\bullet)$}
      \ncangle[angleA=180,angleB=90,fillstyle=none,offsetA=0.2,offsetB=0]{p1}{prod3}
      \naput[npos=0.5]{$\it Im(\bullet)$}


      \nclist{ncline}[naput]{prod2,lp1 $D_i$,ad1 $I(t)$,salida2 $I(n)$}
      \nclist{ncline}[naput]{prod3,lp2 $D_r$,ad2 $Q(t)$,salida3 $Q(n)$}
      
    \end{pspicture}
  \end{figure}
#+END_LATEX

   #+LABEL: fig-espectros-modulador-ideal
   #+CAPTION: Espectro de las señales en las diferentes fases del demodulador
   #+ATTR_LaTeX: width=0.7\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  MPM = 2; 

  subplot(511);
  entrada = triangulo(40,1300,3000,MPM) .+ triangulo(40,-1300,3000,MPM);
  plot(-length(entrada)/2+1:length(entrada)/2,entrada, 'linewidth', 4);
  legend('A');
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();  
  
  subplot(512);
  por_coseno = triangulo(40,2400,5000,MPM) + triangulo(40,200,5000,MPM) + triangulo(40,-2400,5000,MPM) + triangulo(40,-200,5000,MPM);
  plot(-length(por_coseno)/2+1:length(por_coseno)/2,por_coseno, 'linewidth', 4);
  legend('B');
  axis([-length(por_coseno)/2+1 length(por_coseno)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();  
  
  subplot(513);
  filtrado = triangulo(40,200,480,MPM) + triangulo(40,-200,480,MPM);
  plot(-length(filtrado)/2+1:length(filtrado)/2,filtrado, 'linewidth', 4);
  legend('C');
  axis([-length(filtrado)/2+1 length(filtrado)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();  
  
  subplot(514);
  por_coseno2 = 2*triangulo(40,0,880,MPM) + triangulo(40,-400,880,MPM) + triangulo(40,400,880,MPM);
  plot(-length(por_coseno2)/2+1:length(por_coseno2)/2,por_coseno2, 'linewidth', 4);
  legend('|D_r+D_i|');
  axis([-length(por_coseno2)/2+1 length(por_coseno2)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();  
  
  subplot(515);
  ultimo = 2*triangulo(40,0,80,MPM);
  plot(-length(ultimo)/2+1:length(ultimo)/2,ultimo, 'linewidth', 4);
  legend('|I+jQ|');
  axis([-length(ultimo)/2+1 length(ultimo)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();  
  
  ans = guardarImagenOctave("img/espectros-demodulador-ideal.pdf");
#+end_src
#+results:
   [[file:img/espectros-demodulador-ideal.pdf]]
   
** Ejercicio 7
   El modulador lo que hace es desplazar el espectro de la chirp hasta
   los 1300Mhz (la modula) y luego la emite. Esta señal es reflejada
   por el suelo y vuelve al radar. Como estamos considerando que la
   señal al viajar hasta el suelo, rebotar y volver está pasando por
   un sistema LTI que solo introduce un retardo y un cambio de fase,
   la señal que recibe el radar es la misma que emitió, solo que con
   algún cambio de fase. Luego se pasa la señal a una banda intermedia
   de 200Mhz y por último es multiplicada por un coseno de 200Mhz en
   el caso de $I(t)$ o por un seno de la misma frecuencia para el caso
   de $Q(t)$. Entonces, las señales $I(t)$ y $Q(t)$, no son mas que
   las pertes real e imaginaria de la chirp emitida por el SARAT
   retrazada y con un cambio de fase.

** Ejercicio 8
  Tanto el modulador como el demodulador son sistemas LTI. Como
  consideramos el mundo fuera del SARAT como un sistema LTI, entonces
  todo el sistema en su totalidad es LTI.

\newpage
* Parte digital
** Ejercicio 9
   #+LABEL: fig-datos-crudos
   #+CAPTION: Datos crudos del SARAT (subset)
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src matlab :exports results :results file
  colormap('gray');
  
  datos = cargarMatrizCompleta();
  
  datos = 10*log10(abs(datos));
  
  imagesc(datos);
  
  ans = guardarImagenjpg('img/datos-crudos.jpg');
#+end_src
#+results:
   [[file:img/datos-crudos.jpg]]

   Podemos ver en la figura \ref{fig-datos-crudos}, que la ventana de
   recepción (ancho total de la imagen) dura 3000 muestras y que en
   cada línea (exceptuando las primeras 200) hay una región muy oscura
   al inicio de aproximadamente 395 muestras. Las primeras 200 lineas
   contienen solamente un muestreo de la chirp emitida por el
   SARAT. La duración de esta chirp es de 500 muestras o $10\mu
   s$. Entonces conociendo esta equivalencia entre cantidad de
   muestras y tiempo, podemos calcular que la ventana de adquisición
   dura $60 \mu s$. También sabemos que las 395 muestras al inicio de
   cada fila equivalen a $7.9 \mu s$ que es el tiempo desde que se
   abre la ventana de recepción hasta que comienzan a llegar los
   datos. Si hacemos el cálculo teórico vemos que estamos tomando
   muestras a 50Mhz y que la cantidad de muestras horizontales es de
   3000, entonces $\frac{3000}{50\times 10^6} = 60\times10^{-6} = 60
   \mu s$.

** Ejercicio 10

   En el punto anterior, las chirp aparecían de un color uniforme
   debido a que su modulo, en decibeles, es parecido a un pulso
   rectangular (mas bien trapezoidal). Es decir que sube rápidamente,
   se mantiene un tiempo y luego baja (figura
   \ref{fig-chirp-real-modulo}).

   #+LABEL: fig-chirp-real-modulo
   #+CAPTION: Chirp real del SARAT (modulo en decibeles)
   #+ATTR_LaTeX: width=0.6\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  chirp_real = cargarChirp();
  plot(1:length(chirp_real),10*log10(chirp_real), 'linewidth', 4);
  cambiarEjeX("%.00fus",1e6/Fs);
  cambiarEjeY("%ddB", 1);
  grid();
  ans = guardarImagenOctave("img/chirp-real-logmodulo.pdf");
#+end_src
#+results:
   [[file:img/chirp-real-logmodulo.pdf]]

   #+LABEL: fig-chirp-real-espectro
   #+CAPTION: Chirp real del SARAT (espectro)
   #+ATTR_LaTeX: width=0.6\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  chirp_real = cargarChirp();
  espectro = fftshift(abs(fft(chirp_real)));
  plot(-length(espectro)/2+1:length(espectro)/2,10*log10(espectro), 'linewidth', 4);
  axis([-length(espectro)/2+1 length(espectro)/2])
  cambiarEjeX("%.0fMhz",1/10);
  cambiarEjeY("%ddB", 1);
  grid();
  ans = guardarImagen("img/chirp-real-espectro.pdf");
#+end_src
#+results:
   [[file:img/chirp-real-espectro.pdf]]

   #+LABEL: fig-chirp-real-espectro-ancho-banda
   #+CAPTION: Chirp real del SARAT (ancho de banda)
   #+ATTR_LaTeX: width=0.6\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  suavizado=32;
  chirp_real = cargarChirp();
  espectro = fftshift(abs(fft(chirp_real)));
  espectro = espectro.';
  espectro = suavizar(espectro,suavizado);
  espectro = 10*log10(espectro);
  offset= -length(espectro)/2+1;
  plot(offset:length(espectro)/2,espectro, 'linewidth',4);
  
  maxdb = prctile(espectro(suavizado:end-suavizado),90);
  indices = find(espectro >= maxdb-3); 
  fc1 = indices(1);
  fc2 = indices(end);
  
  bw = (fc2-fc1)/10;
  
  axis([-length(espectro)/2+1 length(espectro)/2 20 50])
  cambiarEjeX('%.0fMhz',1/10);
  cambiarEjeY('%ddB', 1);
  grid();
  

  text(-130,32, ['fc1: ',num2str(fc1/10-25), 'Mhz'], 'fontsize', 20);  
  text(-130,28, ['fc2: ',num2str(fc2/10-25), 'Mhz'], 'fontsize', 20);  
  text(-130,24, ['Ancho de banda: ',num2str(bw), 'Mhz'], 'fontsize', 20);

  
  ans = guardarImagenOctave('img/chirp-real-ancho-banda.pdf');
#+end_src
#+results:
   [[file:img/chirp-real-ancho-banda.pdf]]

   #+LABEL: fig-chirp-real
   #+CAPTION: Chirp real del SARAT
   #+ATTR_LaTeX: angle=-90,width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  datos = cargarMatriz();
  subplot(311);
  chirp_real = cargarChirp();
  plot(0:499,real(chirp_real),'linewidth', 4)
  title('Parte Real');
  subplot(312);
  plot(0:499,imag(chirp_real),'linewidth', 4)
  title('Parte Imaginaria');
  subplot(313);
  plot(0:499,angle(chirp_real),'linewidth', 4)
  title('Fase');
  axis([0 499 -pi pi])
  set(gca, 'ytick', [-pi -pi/2 0 pi/2 pi])
  set(gca, 'interpreter', 'tex');
  set(gca,'YTickLabel',{'-\pi' '-\pi/2' '0' '\pi/2' '\pi'}, 'interpreter', 'tex');
  ans = guardarImagen("img/chirp-real.pdf");
#+end_src
#+results:
   [[file:img/chirp-real.pdf]]

** Ejercicio 11

   #+LABEL: fig-modulo-espectro-rango
   #+CAPTION: Modulo del espectro en rango
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  datos_no_chirp = cargarMatrizCompleta();
  datos_no_chirp = datos_no_chirp(201:end,395:end);
  espectros = fft(datos_no_chirp, [] ,2); #fft de cada fila
  
  argumentos = arg(espectros);
  argumento =  sum(argumentos,1)/rows(datos_no_chirp);
  
  espectro = sum(abs(fftshift(espectros)),1)/rows(datos_no_chirp);
  
  subplot(211);
  plot(-length(espectro)/2+1:length(espectro)/2, 10*log10(espectro), 'linewidth', 4)
  axis([-length(espectro)/2+1 length(espectro)/2])
  cambiarEjeY("%ddB", 1);
  cambiarEjeX("%0.0fMhz", (Fs/2)/(length(espectro)/2) * 1e-6);
  grid();
  
  subplot(212);
  plot(-length(espectro)/2+1:length(espectro)/2, argumento, 'linewidth', 4)
  set(gca, 'ytick', [-pi -pi/2 0 pi/2 pi])
  set(gca, 'interpreter', 'tex');
  set(gca,'YTickLabel',{'-\pi' '-\pi/2' '0' '\pi/2' '\pi'}, 'interpreter', 'tex');
  cambiarEjeX("%0.0fus", 1e6/Fs);
  grid();
  
  ans = guardarImagenOctave("img/espectro-rango.pdf");
#+end_src
#+results:
   [[file:img/espectro-rango.pdf]]

   #+LABEL: fig-modulo-espectro-azimuth
   #+CAPTION: Modulo del espectro en azimuth
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  datos_no_chirp = cargarMatrizCompleta();
  datos_no_chirp = datos_no_chirp(201:end,350:end);
  espectros = fftshift(abs(fft(datos_no_chirp, [] ,1))); #fft de cada columna
  espectro = sum(espectros,2)/columns(datos_no_chirp);
  plot(-length(espectro)/2+1:length(espectro)/2, 10*log10(espectro), 'linewidth', 4)

  axis([-length(espectro)/2+1 length(espectro)/2])
  cambiarEjeY("%ddB", 1);
  cambiarEjeX("%0.0fHz", (PRF/2)/(length(espectro)/2));
  
  grid();
  ans = guardarImagenOctave("img/espectro-azimuth.pdf");
#+end_src
#+results:
   [[file:img/espectro-azimuth.pdf]]

** Ejercicio 12

   #+LABEL: fig-modulo-espectro-azimuth-medio-prf
   #+CAPTION: Modulo del espectro en azimuth (medio PRF)
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  datos_no_chirp = cargarMatrizCompleta();
  datos_no_chirp = datos_no_chirp(201:end,350:end);
  datos_no_chirp = datos_no_chirp(1:2:end,:);
  espectros = fftshift(abs(fft(datos_no_chirp, [] ,1))); #fft de cada columna
  espectro = sum(espectros,2)/columns(datos_no_chirp);
  plot(-length(espectro)/2+1:length(espectro)/2, 10*log10(espectro), 'linewidth', 4)
  
  axis([-length(espectro)/2+1 length(espectro)/2])
  
  cambiarEjeY("%ddB", 1);
  cambiarEjeX("%0.0fHz", (PRF/4)/(length(espectro)/2));
  
  grid();
  ans = guardarImagen("img/espectro-azimuth-medio-prf.pdf");
#+end_src
#+results:
   [[file:img/espectro-azimuth-medio-prf.pdf]]


\newpage
* Compresión del pulso
** Ejercicio 13

   La correlación no es una operación conmutativa. La relación entre
   la correlación de dos funciones con su transformada de Fourier es
   la siguiente:
#+BEGIN_LATEX
  \begin{eqnarray*}
    {\mathcal F}| x[n] \star y[n]|(\Omega) &=& \sum_{n=-\infty}^{\infty} x[n] \star y[n] e^{-j\Omega n} \\
    &=& \sum_{n=-\infty}^{\infty} \sum_{k=-\infty}^{\infty} x[k] y^*[k-n] e^{-j\Omega n} \\
    &=& \sum_{k=-\infty}^{\infty} x[k] \sum_{n=-\infty}^{\infty} y^*[k-n] e^{-j\Omega n} \\
    &=& \sum_{k=-\infty}^{\infty} x[k] \sum_{l=-\infty}^{\infty} y^*[l] e^{-j\Omega (k-l)} \\
    &=& \sum_{k=-\infty}^{\infty} x[k] e^{-j\Omega k} \sum_{l=-\infty}^{\infty} y^*[l] e^{j\Omega l} \\
    &=& X(\Omega) \left(\sum_{l=-\infty}^{\infty} y[l] e^{-j\Omega l}\right)^* \\
    &=& X(\Omega) \left(Y(\Omega)\right)^* \\
    &=& X(\Omega) Y^*(\Omega) \\
  \end{eqnarray*}
  
#+END_LATEX

   Entonces, por ejemplo si tenemos una $X(\Omega)$ real y una
   $Y(\Omega)$ imaginaria, no es lo mismo 

   $${\mathcal F}| x[n] \star y[n]|(\Omega) = X(\Omega) Y^*(\Omega) = X(\Omega) (-1)Y(\Omega)$$

   que

   $${\mathcal F}| y[n] \star x[n]|(\Omega) = Y(\Omega) X^*(\Omega) = Y(\Omega) X(\Omega)$$

   Por lo tanto la correlación no es una operación conmutativa.

** Ejercicio 14

   En la figura \ref{fig-simulacion-autocorrelacion} se puede apreciar
   la autocorrelación de la chirp. El ancho del lóbulo principal es de
   unos $0.4\mu s$. Como estamos mandando una señal de $10\mu s$ y
   resulta en un pulso de $0.4 \mu s$ la compresión de pulso se da en
   un factor de $\frac{10 \mu s}{0.12 \mu s} \approx 83$. Si
   quisieramos obtener la misma resolución con un pulso convencional
   necesitaríamos en el radar un generador de alta potencia ya que
   mientras mas angosto el pulso mas difícil es su detección y por lo
   tanto el pulso debe tener mas potencia.

   #+LABEL: fig-simulacion-autocorrelacion
   #+CAPTION: Autocorrelación de la chirp del SARAT
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  chirp = cargarChirp();
  fft_chirp = fft(chirp,length(chirp)*2);
  correlacion = ifft(fft_chirp .* conj(fft_chirp));
  plot(-length(correlacion)/2:length(correlacion)/2-1, fftshift(abs(correlacion)),'linewidth', 2);
  grid();
  axis([-100 100])
  cambiarEjeX("%0.1fus",1/100);
  ans = guardarImagen("img/simulacion-autocorrelacion.pdf");
#+end_src
#+results:
[[file:img/simulacion-autocorrelacion.pdf]]

** Ejercicio 15

   #+LABEL: fig-simulacion-autocorrelacion-dependencia
   #+CAPTION: Autocorrelación de diferentes chirps
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src matlab :exports results :results file
  longitud_t = 10e-6;
  fs = 4*Fs;
  t = 0:1/fs:longitud_t;
  
  chirps{1} = {mi_chirp(-2.5e-6,2.5e6,0,longitud_t,t), '5Mhz, 10us'};
  chirps{2} = {mi_chirp(-10e-6,10e6,0,longitud_t,t), '20Mhz, 10us'};
  chirps{3} = {mi_chirp(-20e-6,20e6,0,longitud_t,t), '40Mhz, 10us'};
  chirps{4} = {mi_chirp(-30e-6,30e6,0,longitud_t,t), '60Mhz, 10us'};
  chirps{5} = {mi_chirp(-40e-6,40e6,0,longitud_t,t), '80Mhz, 10us'};
  chirps{6} = {mi_chirp(-50e-6,50e6,0,longitud_t,t), '100Mhz,10us'};
  
  maximo = length(chirps);
  for i = 1:maximo
    subplot(maximo/2,2,i)
  
    chirp = chirps{i}{1};
    fft_chirp = fft(chirp,length(chirp)*2);
  
    correlacion = ifft(fft_chirp .* conj(fft_chirp));
  
    plot(-length(correlacion)/2:length(correlacion)/2-1, fftshift(abs(correlacion)),'linewidth', 0.5);
  
    mitad = correlacion(length(correlacion)/2:end);
    
    indices =find(correlacion <= 100); 
    ancho_principal = indices(1)*2/fs;

    compresion = longitud_t/ancho_principal;
  
    text(120,1300, ['Compresion: ', num2str(compresion,'%0.0f')]);
    title(chirps{i}{2});
    axis([-2000 2000 0 2000]);
  
    cambiarEjeX('%0.0fus',1/100);
  
    grid();
  end
  
  ans = guardarImagen('img/simulacion-autocorrelacion-dependencia.pdf');
  
#+end_src
#+results:
   [[file:img/simulacion-autocorrelacion-dependencia.pdf]]


   #+LABEL: fig-simulacion-autocorrelacion-dependencia-temporal
   #+CAPTION: Autocorrelación de diferentes chirps (variación del ancho temporal)
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src matlab :exports results :results file
  fs = 4*Fs;
  longitud_t = 10e-6;
  t = 0:1/fs:longitud_t;
  
  chirps{1} = {mi_chirp(-2.5e-6,2.5e6,0,10e-6,t), 10e-6};
  chirps{2} = {mi_chirp(-2.5e-6,2.5e6,0,15e-6,t), 15e-6};
  chirps{3} = {mi_chirp(-2.5e-6,2.5e6,0,30e-6,t), 30e-6};
  chirps{4} = {mi_chirp(-2.5e-6,2.5e6,0,50e-6,t), 50e-6};
  
  maximo = length(chirps);
  for i = 1:maximo
    subplot(maximo/2,2,i)

    chirp = chirps{i}{1};
    fft_chirp = fft(chirp,length(chirp)*2);

    correlacion = ifft(fft_chirp .* conj(fft_chirp));

    plot(-length(correlacion)/2+1:length(correlacion)/2, fftshift(abs(correlacion)),'linewidth', 0.5);

    mitad = correlacion(length(correlacion)/2:end);

    indices =find(correlacion <= 100); 
    ancho_principal = indices(1)*2/fs;

    longitud_t = chirps{i}{2};

    compresion = longitud_t/ancho_principal;

    text(120,1300, ['Compresion: ', num2str(compresion,'%0.0f')]);
    title(num2str(chirps{i}{2}*1e6,'5Mhz, %0.0fus'));
    axis([-2000 2000 0 2000]);

    cambiarEjeX('%0.0fus',1/100);

    grid();
  end

  ans = guardarImagen('img/simulacion-autocorrelacion-dependencia-temporal.pdf');
#+end_src
#+results:
   [[file:img/simulacion-autocorrelacion-dependencia-temporal.pdf]]
   

** Ejercicio 16

   La correlación se define como:

   $$x[n] \star y[n] = \sum_{k=-\infty}^{\infty} x[k] y^*[k-n]$$

   y como ya vimos,la transformada de la correlacion es:

   $${\mathcal F}| x[n] \star y[n]|(\Omega) = X(\Omega) Y^*(\Omega)$$

   donde $X(\Omega)$ es la transformada de Fourier de $x[n]$, y
   $Y^*(\Omega)$ es la transformada de Fourier conjugada de $y[n]$.

   Si hacemos un remplazo $\widetilde{Y}(\Omega) = Y^*(\Omega)$, nos queda
   que 

   $${\mathcal F}| x[n] \star y[n]|(\Omega) = X(\Omega) \widetilde{Y}(\Omega)$$

   Entonces, en tiempo podemos pensarlo como 

   $$x[n] \star y[n] = x[n] * \tilde{y}[n]$$

   Entonces, se puede calcular la convolución utilizando DFT

   $$x[n] * \tilde{y}[n] = IDFT(DFT(x,N) DFT(\tilde{y},N))$$

   donde $N = length(x)+length(\tilde{y})-1$ y además, por lo visto
   anteriormente 

   $$DFT(\tilde{y},N) = DFT(y,N)^*$$

   Por lo tanto 

   $$x[n] \star y[n] = x[n] * \tilde{y}[n] = IDFT(DFT(x,N) DFT(y,N)^*)$$

\newpage   

* Compresión en rango
** Ejercicio 17
   #+LABEL: fig-compresion-en-rango
   #+CAPTION: Compresion en rango
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src matlab :exports results :results file
  tic
  chirp = cargarChirp();
  datos = cargarMatrizCompleta();
  datos_no_chirp = datos(201:end,:);
  
  factor = 2;
  
  tic
  datos_no_chirp_t = datos_no_chirp.';
  toc
  clear datos_no_chirp;
  
  longitud = rows(datos_no_chirp_t) + length(chirp) -1;
  
  tic
  fft_chirp_t = conj(fft(chirp,longitud)) .';
  fft_datos_t = fft(datos_no_chirp_t,longitud,1);
  toc
  clear datos_no_chirp_t;
  
  tic
  for i = 1:columns(fft_datos_t)
    fft_datos_t(:,i) = ifft(fft_chirp_t .* fft_datos_t(:,i));
  end
  toc
  
  clear fft_chirp_t;
  
  colormap('gray');
  fft_datos_t = fft_datos_t.';
  
  %save('data/comprimida-en-rango-completa.mat', 'fft_datos_t');
  
  fft_datos_t = 10*log10(abs(fft_datos_t));
  
  tic
  imagesc(fft_datos_t);
  toc
  
  tic
  ans = guardarImagenjpg('img/compresion-en-rango.jpg');
  toc
  
  toc
#+end_src
#+results:
   [[file:img/compresion-en-rango.jpg]]
\newpage
* Compresión en azimuth
** Opcional 1

   #+LABEL: fig-longitud-chirp-vs-angulo
   #+CAPTION: Duración de la chirp en función del \eta_rango
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  v_plat = 108;  #108 m/s
  
  w_footprint = 6.16*pi/180; #6.16°
  
  n_near = 18.24*pi/180; #18.24°
  
  c = 299792458; #m/s
  
  h = 5375; #m
  
  Ts = 1/50e+6;
  
  k=0:3500;
  
  y_rango0 = h / cos(n_near);
  
  y_rango = y_rango0 + k .* (c * Ts) ./2
  
  ancho_f = 2* y_rango .* tan(w_footprint/2);
  
  t_chirp = ancho_f / v_plat;
  
  plot(acos((h./y_rango))*180/pi,t_chirp, 'linewidth', 3);
  axis([15 72])
  grid();
  
  save("-mat", "data/duraciones.mat", "t_chirp");
  
  cambiarEjeX("%d^o",1);
  cambiarEjeY("%ds", 1);
  
  ans = guardarImagen("img/longitud-chirp-vs-angulo.pdf");
  
#+end_src
#+results:
   [[file:img/longitud-chirp-vs-angulo.pdf]]

** Ejercicio 18

   #+LABEL: fig-frecuencias-corte
   #+CAPTION: Frecuencias de corte en azimuth y ancho de banda
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src matlab :exports results :results file
  PRF = 250;
  
  en_rango = load('data/comprimida-en-rango-completa.mat');
  en_rango = en_rango.fft_datos_t;
  
  ancho_total = columns(en_rango);
  alto_total = rows(en_rango);
    
  transformadas = 10*log10(abs(fftshift(fft(en_rango,[],1),1)));
  clear en_rango;
  
  n=128;
  tam = rows(transformadas);
  filtro = rectwin(n) / n;
  filtro = bartlett(n) / sum(bartlett(n));
  
  transformadas2 = transformadas;
  
  tic
  for i= 1:columns(transformadas)
      temp = abs(ifft(fft(transformadas(:,i),2*tam).*fft(filtro,2*tam)));
    transformadas2(:,i) = temp(1:end/2);
  end
  toc
  
  rango = -(rows(transformadas)/2)+1:(rows(transformadas)/2);
  
  clear transformadas;
  
  maxdb = prctile(transformadas2, 90,1)-3;
      
  tic
  for i = 1:columns(transformadas2)
    indices =find(transformadas2(:,i) >= maxdb(i)); 
    fc1(i) = indices(1);
    fc2(i) = indices(end);
  end
  toc
  
  fc1=(fc1-rango(end))*PRF/(2*rango(end));
  fc2=(fc2-rango(end))*PRF/(2*rango(end));
  bw = fc2-fc1;
  centroide = (fc1+fc2)/2;
  
  figure()
  hold on
  plot(fc1, 'linewidth', 1);
  plot(fc2, 'color', 'red','linewidth', 1);
  plot(bw, 'color', 'g', 'linewidth', 1);
  plot(centroide, 'color', 'm', 'linewidth', 1);
  axis([395 length(fc1)-500 -125 170]);
  grid();
  legend('fc1', 'fc2', 'BW', 'Centroide doppler');
  cambiarEjeY('%0.0fHz', 1);
  hold off;
  
  %save('data/frecuencias.mat', 'fc1', 'fc2', 'bw');
  
  ans = guardarImagen('img/frecuencias-de-corte.pdf');
  
#+end_src
#+results:
   [[file:img/frecuencias-de-corte.pdf]]
   


** Ejercicio 19

   Para obtener una segunda aproximación de las frecuencias de corte,
   ancho de banda y centroide doppler de los datos en azimuth, se
   utilizó un promediador móvil implementado con una ventana de
   Bartlett de ancho 15. Si llamamos $x[n]$ a la n-esima columna de la
   matriz (datos en azimuth) antes de promediar, e $y[n]$ a la n-esima
   columna de la matriz luego de promediar, tenemos que

   $$y[n] = \frac{a_0 x[n] + a_1 x[n+1] + a_2 x[n+2] + \cdots + a_13 x[n+13] + a_14 x[n+14]}{N}$$

   Donde $a_n$ son coeficientes que forman una ventana de bartlett de
   ancho 15 y $\displaystyle N = \sum_{n=0}^{14} a_n$.

   #+LABEL: fig-frecuencias-corte-segunda-estimacion
   #+CAPTION: Frecuencias de corte en azimuth y ancho de banda (segunda estimación)
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src matlab :exports results :results file
  PRF = 250;
  
  en_rango = load('data/comprimida-en-rango-completa.mat');
  en_rango = en_rango.fft_datos_t;
  
  ancho_total = columns(en_rango);
  alto_total = rows(en_rango);
    
  transformadas = 10*log10(abs(fftshift(fft(en_rango,[],1),1)));
  rango = -(rows(transformadas)/2)+1:(rows(transformadas)/2);
  clear en_rango;
  
  n=128;
  tam = rows(transformadas);
  filtro = rectwin(n) / n;
  filtro = bartlett(n) / sum(bartlett(n));
  
  transformadas2 = transformadas;
  
  tic
  for i= 1:columns(transformadas)
      temp = abs(ifft(fft(transformadas(:,i),2*tam).*fft(filtro,2*tam)));
      transformadas2(:,i) = temp(1:end/2);
  end
  toc
  
  clear transformadas;
  
  transformadas2 = transformadas2.';
  
  n=15;
  tam = rows(transformadas2);
  filtro = rectwin(n) / n;
  filtro = bartlett(n) / sum(bartlett(n));
  
  transformadas3 = transformadas2;
  
  tic
  for i= 1:columns(transformadas2)
    temp = abs(ifft(fft(transformadas2(:,i),2*tam).*fft(filtro,2*tam)));
    transformadas3(:,i) = temp(1:end/2);
  end
  toc
  clear transformadas2;
  
  transformadas3 = transformadas3.';
  
  maxdb = prctile(transformadas3, 90,1)-3;
  
  tic
  for i = 1:columns(transformadas3)
    indices =find(transformadas3(:,i) >= maxdb(i)); 
    fc1(i) = indices(1);
    fc2(i) = indices(end);
  end
  toc
  
  fc1=(fc1-rango(end))*PRF/(2*rango(end));
  fc2=(fc2-rango(end))*PRF/(2*rango(end));
  bw = fc2-fc1;
  centroide = (fc1+fc2)/2;
  
  hold on
  plot(fc1, 'linewidth', 1);
  plot(fc2, 'color', 'red','linewidth', 1);
  plot(bw, 'color', 'g', 'linewidth', 1);
  plot(centroide, 'color', 'm', 'linewidth', 1);
  axis([395 length(fc1)-500 -125 170]);
  grid();
  legend('fc1', 'fc2', 'BW', 'Centroide doppler');
  cambiarEjeY('%0.0fHz', 1);
  hold off;
  
  save('data/frecuencias.mat', 'fc1', 'fc2', 'bw');
  
  ans = guardarImagen('img/frecuencias-de-corte-2.pdf');
#+end_src
#+results:
   [[file:img/frecuencias-de-corte-2.pdf]]

** Ejercicio 20

   El ancho de banda de las chirps se encuentra ligeremente por arriba
   de los 100Mhz y su duración temporal depende del $\eta-rango$ y se
   puede observar en la figura
   \ref{fig-longitud-chirp-vs-angulo}. Como el factor de compresión no
   depende del ancho temporal, es el mismo para todas las chirps en
   azimuth y es aproximadamente 273.

   #+LABEL: fig-simulacion-autocorrelacion-azimuth
   #+CAPTION: Autocorrelación de la chirp en azimuth
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  Fs=1000;
  t = 0:1/Fs:6;
  chirp = mi_chirp(-50, 50 ,0, 6, t);
  fft_chirp = fft(chirp,length(chirp)*2);
  correlacion = ifft(fft_chirp .* conj(fft_chirp));

  plot(-length(correlacion)/2:length(correlacion)/2-1, fftshift(abs(correlacion)),'linewidth', 2);

    mitad = correlacion(length(correlacion)/2:end);
    
    indices =find(correlacion <= 100); 
    ancho_principal = (indices(1)*2)/Fs;

    compresion = 6/ancho_principal;
  
    text(20,1300, ['Compresion: ', num2str(compresion,'%0.0f')]);

  grid();
  axis([-50 50 0 3000]);
  cambiarEjeX("%0.2fs",1/Fs);

  ans = guardarImagen("img/simulacion-autocorrelacion-azimuth.pdf");
#+end_src
#+results:
[[file:img/simulacion-autocorrelacion-azimuth.pdf]]


** Ejercicio 22

   #+LABEL: fig-compresion-azimuth
   #+CAPTION: Imagen comprimida en azimuth
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src matlab :exports results :results file
  PRF = 250;
  
  frecuencias = load('data/frecuencias.mat');
  fc1 = frecuencias.fc1;
  fc2 = frecuencias.fc2;
  bw = frecuencias.bw;
  
  duracion = load('data/duraciones.mat');
  duracion = duracion.t_chirp;
  
  matriz = load('data/comprimida-en-rango-completa.mat');
  matriz = matriz.fft_datos_t;
  
  l_max = ceil(rows(matriz())+duracion(end-500)*PRF-1);
  
  matriz = fft(matriz,l_max);
  
  tic
  comprimida = matriz;
  for i=1:columns(matriz)
  
    t = 0:1/PRF:duracion(end-500);
  
    chirp_az = mi_chirp(fc1(i), fc2(i), bw(i), duracion(i), t)';
    comprimida(:,i) = ifft(fft(chirp_az,l_max) .* matriz(:,i));
  end
  toc
  clear matriz;

  colormap('gray');
  comprimida = 10*log10(abs(comprimida(1:end,395:end-500)));
  imagesc(comprimida);
  ans = guardarImagenjpg('img/azimuth-1.jpg');
  
#+end_src
#+results:
   [[file:img/azimuth-1.jpg]]


   #+LABEL: fig-ventana-kaiser
   #+CAPTION: Ventana utilizada
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file

   ventana = kaiser(100, 2.14)

   subplot(311);
   stem(0:length(ventana)-1, ventana, 'linewidth', 3);
   grid();
   legend('Kaiser(2.14)');

   subplot(312);

   stem(0:length(ventana)-1, 10*log10(ventana), 'linewidth', 3);

   text(37,-2.5,'10*log_{10}(Kaiser(2.14))');
   cambiarEjeY('%ddb',1);
   grid();

   subplot(313);
   stem(-length(ventana)/2:length(ventana)/2-1, fftshift(abs(fft(ventana))), 'linewidth', 3);

   legend('|DFT(Kaiser(2.14))|');
   axis([-length(ventana)/2 length(ventana)/2-1]);
   set(gca, 'interpreter', 'tex');

   cambiarEjeX('%0.1f ',2/length(ventana));

  set(gca, 'xtick', [-length(ventana)/2 -length(ventana)/4 0 length(ventana)/4-1 length(ventana)/2-1])
  set(gca, 'interpreter', 'tex');
  set(gca,'XTickLabel',{'-\pi' '-\pi/2' '0' '\pi/2' '\pi'}, 'interpreter', 'tex');

   grid();

   ans = guardarImagen('img/kaiser-4db.pdf');
#+end_src
#+results:
   [[file:img/kaiser-4db.pdf]]

   #+LABEL: fig-compresion-azimuth-kaiser
   #+CAPTION: Imagen comprimida en azimuth (con ventaneo en la chirp)
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src matlab :exports results :results file
  PRF = 250;
  
  frecuencias = load('data/frecuencias.mat');
  fc1 = frecuencias.fc1;
  fc2 = frecuencias.fc2;
  bw = frecuencias.bw;
  
  duracion = load('data/duraciones.mat');
  duracion = duracion.t_chirp;
  
  matriz = load('data/comprimida-en-rango-completa.mat');
  matriz = matriz.fft_datos_t;
  
  l_max = ceil(rows(matriz())+duracion(end-500)*PRF-1);
  
  matriz = fft(matriz,l_max);
  
  tic
  comprimida = matriz;
  for i=1:columns(matriz)
  
    t = 0:1/PRF:duracion(end-500);
  
    chirp_az = mi_chirp(fc1(i), fc2(i), bw(i), duracion(i), t)';
    chirp_az = chirp_az .* kaiser(length(chirp_az), 2.14);
    comprimida(:,i) = ifft(fft(chirp_az,l_max) .* matriz(:,i));
  end
  toc

  clear matriz;
  azimuth =  10*log10(abs(comprimida));
  clear comprimida;
  save('data/comprimida-en-azimuth.mat', 'azimuth');

  colormap('gray');
  imagesc(azimuth(:,395:end-500));
  ans = guardarImagenjpg('img/azimuth-kaiser.jpg');
#+end_src
#+results:
   [[file:img/azimuth-kaiser.jpg]]


   
   
** Opcional 2
   #+LABEL: fig-compresion-azimuth-kaiser-promediado
   #+CAPTION: Imagen comprimida en azimuth promediado
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src matlab :exports results :results file
  matriz_0 = load('data/comprimida-en-azimuth.mat');
  matriz_0 = matriz_0.azimuth;
  
  n = 8;
  ventana = bartlett(8);
  ventana = ventana / sum(ventana);
  
  longitud = rows(matriz_0)+n-1;
  
  filtro = fft(ventana, longitud);
  matriz = fft(matriz_0, longitud);
  
  filtrada = matriz;
  tic
  for i = 1:columns(matriz)
    filtrada(:,i) = ifft(matriz(:,i).*filtro);
  end
  toc
  clear matriz;
  colormap('gray');
  
  filtrada = filtrada(1:8:end,349:end-500);
  
  imagesc(abs(filtrada));
  
  ans = guardarImagenjpg('img/azimuth-promediada.jpg');
#+end_src
#+results:
   [[file:img/azimuth-promediada.jpg]]



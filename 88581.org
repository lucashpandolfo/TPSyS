#+LATEX_HEADER: \pagestyle{fancy}
#+LATEX_HEADER: \setlength{\parskip}{0.3cm}
#+TITLE: 
#+OPTIONS:  toc:nil
#+LATEX_HEADER: \lhead{\includegraphics[width=1.5cm]{img/Logo-fiuba}} \chead{66.74  - Señales y Sistemas} \rhead{\Huge FIUBA}
#+LATEX_HEADER: \lfoot{88581 - Pandolfo Lucas} \cfoot{\thepage} \rfoot{$2^{do}$ cuatrimestre 2011}

* Principios básicos
** Ejercicio 1
   #+LABEL: fig-r-rangos
   #+CAPTION: \gamma-rangos
   #+ATTR_LaTeX: width=0.6\columnwidth placement=[H]
   [[file:img/r-rangos.pdf]]

#+BEGIN_LATEX
  \begin{eqnarray*}
    R_n &=& sen(\eta_n) r_n \\
    \\
    \Delta R_n &=& R_n - R_{n-1} \\
    \Delta R_n &=&  sen(\eta_n) r_n -  sen(\eta_{n-1}) r_{n-1} \\
    \\
    \\ r_k &=& \frac{k c T_s}{2}\\
    \gamma-rango_k = r_k &=& \frac{h}{cos(\eta_k)}\\
    \\
    \eta_k &=& cos^{-1}\left(\frac{h}{r_k}\right)
  \end{eqnarray*}  
#+END_LATEX

   Para poder graficar $\eta_k$ y $\Delta R_k$, necesitamos primero
   calular $r_o$. Sabiendo que:

#+BEGIN_LATEX
  \begin{eqnarray*}
    Fs &=& 50\, 10^6\\
    Ts &=& \frac{1}{Fs} = 50\, 10^{-6}\\
    h  &=& 5375 m\\
    \eta_0 &=& \eta_{near} = 18.24° \\
    c &=& 299.792.458 \frac{m}{s}  
  \end{eqnarray*}
#+END_LATEX

   Podemos calcular $r_0$ como $\frac{h}{cos(\eta_0)}$ que resulta
   en $$r_0 \approx 5659$$

    #+LABEL: fig-eta-vs-rango
    #+CAPTION: $\eta$ en función del rango $r_k$
    #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  h = 5375;
  n_near = 18.24*pi/180;
  c = 299792458;
  Ts = 50e-6;
  kmax = 20;
  r0 = h/(cos(n_near));
  rangos = r0:c*Ts/2:r0+kmax*c*Ts/2;
  plot(0:kmax,acos(h./rangos)*180/pi, 'linewidth', 4);
  set(gca, 'interpreter', 'tex');
  set(gca, 'ytick', 15:5:90);
  axis([0 kmax 15 90]);
  set(gca, 'xtick', 0:kmax);
  cambiarEjeY("%0.0f^o",1);
  cambiarEjeX("r_{%d}",1);
  grid();
  ans = guardarImagen("img/eta-vs-rango.pdf");
#+end_src
#+results:
   [[file:img/eta-vs-rango.pdf]]

    #+LABEL: fig-deltar-vs-rango
    #+CAPTION: $\Delta R$ en función del rango $r_k$
    #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  h = 5375;
  n_near = 18.24*pi/180;
  c = 299792458;
  Ts = 50e-6;
  kmax = 20;
  r0 = h/(cos(n_near));
  rangos = r0:c*Ts/2:r0+kmax*c*Ts/2;
  etas = acos(h./rangos);
  
  deltas = sin(etas).*rangos-shift(sin(etas).*rangos,1)
  plot(deltas(2:end), 'linewidth', 4);
  axis([1 length(deltas)-1])
  set(gca, 'interpreter', 'tex');
  set(gca, 'xtick', 1:length(deltas)-1);
  cambiarEjeX("r_{%d}",1);

  grid();
  ans = guardarImagen("img/deltaR-vs-rango.pdf");
#+end_src
#+results:
   [[file:img/deltaR-vs-rango.pdf]]
   
\newpage

* Parte analógica
** Ejercicio 2

   La señal chirp se define como

   $$chirp(t) = e^{j\theta(t)}$$

   donde $\theta(t)$ es una función cuadrática del tiempo con forma

   $$\theta(t) = k_1 t^2 + k_2 t$$

   La frecuencia instantánea de la chirp es entonces:

   $$f\_inst(t) = 2 k_1 t + k_2$$

   Como la chirp barre frecuencias que van desde -20Mhz hasta 20Mhz en
   10$\mu s$:

   $$f\_inst(0) = 2 k_1 0 + k_2 = k2 = -20 Mhz$$

   Y al final

#+BEGIN_LATEX
  \begin{eqnarray*}
    f\_inst(10\mu s) = 2 k_1 10\mu s + k_2 &=& 20 Mhz \\
                       2 k_1 10\mu s - 20Mhz &=& 20 Mhz \\
                       k_1 &=& \frac{40Mhz}{2\, 10\mu s}\\
                       k_1 = 2\,\,10^{12}
  \end{eqnarray*}
#+END_LATEX

   Por lo tanto, la fase instantánea es

   $$f\_inst(t) =  4\,10^{12} t^2 - 20\,10^6 t$$

   En la figura \ref{fig-chirp-no-modulada} se puede ver el resultado
   de graficar las partes real e imaginarias de la chirp junto con la
   fase instantánea en función del tiempo.

    #+LABEL: fig-chirp-no-modulada
    #+CAPTION: Chirp emitida por el SARAT (no modulada)
    #+ATTR_LaTeX: angle=-90,width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  t = 0:1/Fs:10e-6
  chirp_nm = chirp_no_modulada(t);
  subplot(311);
  plot(t,real(chirp_nm), "linewidth", 3);
  title("Parte real");
  axis([0 t(end)])
  cambiarEjeX("%.00fus",1e6);
  subplot(312);
  plot(t,imag(chirp_nm), "linewidth", 3);
  title("Parte imaginaria");
  axis([0 t(end)])
  cambiarEjeX("%.00fus",1e6);
  subplot(313);
  plot(t,arg(chirp_nm), "linewidth", 3);
  title("Fase");
  axis([0 t(end) -pi pi])
  cambiarEjeX("%.00fus",1e6);
  set(gca, 'ytick', [-pi -pi/2 0 pi/2 pi])
  set(gca, 'interpreter', 'tex');
  set(gca,'YTickLabel',{'-\pi' '-\pi/2' '0' '\pi/2' '\pi'}, 'interpreter', 'tex');
  ans = guardarImagen("img/chirp-no-modulada.pdf");
#+end_src
#+results:
   [[file:img/chirp-no-modulada.pdf]]


    #+LABEL: fig-chirp-no-modulada-no-nyquist
    #+CAPTION: Chirp emitida por el SARAT (no modulada) submuestreada
    #+ATTR_LaTeX: angle=-90,width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  t = 0:1/(Fs/2):10e-6
  chirp_nm = chirp_no_modulada(t);
  subplot(311);
  plot(t,real(chirp_nm), "linewidth", 3);
  title("Parte real");
  axis([0 t(end)])
  cambiarEjeX("%.00fus",1e6);
  subplot(312);
  plot(t,imag(chirp_nm), "linewidth", 3);
  title("Parte imaginaria");
  axis([0 t(end)])
  cambiarEjeX("%.00fus",1e6);
  subplot(313);
  plot(t,arg(chirp_nm), "linewidth", 3);
  title("Fase");
  axis([0 t(end) -pi pi])
  cambiarEjeX("%.00fus",1e6);
  set(gca, 'ytick', [-pi -pi/2 0 pi/2 pi])
  set(gca, 'interpreter', 'tex');
  set(gca,'YTickLabel',{'-\pi' '-\pi/2' '0' '\pi/2' '\pi'}, 'interpreter', 'tex');
  ans = guardarImagen("img/chirp-no-modulada-submuestreada.pdf");
#+end_src
#+results:
   [[file:img/chirp-no-modulada-submuestreada.pdf]]

    #+LABEL: fig-espectro-chirp-no-modulada
    #+CAPTION: Espectro de la  Chirp emitida por el SARAT (no modulada)
    #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  t = 0:1/(Fs):10e-6
  chirp_nm = chirp_no_modulada(t);
  espectro = fftshift(abs(fft(chirp_nm)));
  plot(Fs/t(end) * t -Fs/2,20*log10(espectro), "linewidth", 3);
  axis([-Fs/2 Fs/2 0 30])
  cambiarEjeX("%0.0fMhz", 1/1e6);
  cambiarEjeY("%ddB", 1);
  grid();
  ans = guardarImagen("img/espectro-chirp-no-modulada.pdf");
#+end_src
#+results:
   [[file:img/espectro-chirp-no-modulada.pdf]]

   La chirp tiene una frecuencia máxima de 20Mhz y por Nyquist la
   mínima frecuencia de muestreo que podemos usar es 40Mhz, si no se
   satisface el criterio de Nyquist se producen resultados como el de
   la figura \ref{fig-chirp-no-modulada-no-nyquist}.

** Ejercicio 3

    #+LABEL: fig-chirp-no-modulada-espectrograma
    #+CAPTION: Espectrograma de la Chirp emitida por el SARAT (no modulada)
    #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  t = 0:1/Fs:10e-6*10;
  chirp_nm = real(chirp_no_modulada(t))
  specgram(chirp_nm,[],Fs,50,40);
  cambiarEjeY("%0.0fMhz", 1e-6);
  cambiarEjeX("%0.0fus", 1e6);
  ans = guardarImagen("img/chirp-no-modulada-espectro.pdf");
#+end_src
#+results:
   [[file:img/chirp-no-modulada-espectro.pdf]]

    #+LABEL: fig-chirp-no-modulada-espectrograma-submuestreada
    #+CAPTION: Espectrograma de la Chirp emitida por el SARAT (no modulada) submuestreada
    #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  t = 0:1/(Fs/2):10e-6*10;
  chirp_nm = real(chirp_no_modulada(t))
  specgram(chirp_nm,[],Fs/2,50,40);
  cambiarEjeY("%0.0fMhz", 1e-6);
  cambiarEjeX("%0.0fus", 1e6);
  ans = guardarImagen("img/chirp-no-modulada-espectro-submuestreada.pdf");
#+end_src
#+results:
   [[file:img/chirp-no-modulada-espectro-submuestreada.pdf]]

   El uso de diferentes tipos de ventana altera los contenidos de
   frecuencia de la señal original. En las figura
   \ref{fig-comparacion-ventanas} se muestra una comparación de
   aplicar diferentes tipos de ventanas a las primeras 100 muestras de
   la chirp generada en puntos anteriores y en la figura
   \ref{fig-comparacion-ventanas2} se muestran los resultados de
   utilizar cada una de estas ventanas al espectrograma.

    #+LABEL: fig-comparacion-ventanas
    #+CAPTION: Comparación de diferentes tipos de ventanas
    #+ATTR_LaTeX: angle=-90,width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  t = 0:1/(Fs):10e-6*10;
  chirp_nm = real(chirp_no_modulada(t))
  longitud = 100;
  inicio = 1;
  chirp_window = chirp_nm(inicio:inicio+longitud-1);
  ventanas{1} = {rectwin(longitud), "Rectangular"};
  ventanas{2} = {tukeywin(longitud), "Tukey"};
  ventanas{3} = {hann(longitud), "Hann"};
  ventanas{4} = {bartlett(longitud), "Bartlett"};
  
  max = length(ventanas);
  for i = 1:max
    subplot(max,2,2*i-1)
    plot(ventanas{i}{1}, 'linewidth', 3);
    title(ventanas{i}{2});
    subplot(max,2,2*i)
    plot((-longitud/2+1:longitud/2) ,abs(fftshift(fft(ventanas{i}{1}.'.*chirp_window))),'linewidth', 3);
    cambiarEjeX("%0.0fMhz",Fs*2/longitud * 1e-6);
    grid();
  end
  ans = guardarImagen("img/comparacion-ventanas.pdf");
#+end_src
#+results:
[[file:img/comparacion-ventanas.pdf]]

    #+LABEL: fig-comparacion-ventanas2
    #+CAPTION: Comparación de diferentes tipos de ventanas (espectrogramas)
    #+ATTR_LaTeX: angle=-90,width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  t = 0:1/(Fs):10e-6*10;
  chirp_nm = real(chirp_no_modulada(t))
  longitud = 50;
  solapamiento= 25;
  inicio = 20;
  chirp_window = chirp_nm(inicio:inicio+longitud-1);
  ventanas{1} = {rectwin(longitud), "Rectangular"};
  ventanas{2} = {tukeywin(longitud), "Tukey"};
  ventanas{3} = {hann(longitud), "Hann"};
  ventanas{4} = {bartlett(longitud), "Bartlett"};
  
  max = length(ventanas);
  for i = 1:max
    subplot(max/2,2,i)
    specgram(chirp_nm,[],Fs,ventanas{i}{1},solapamiento);
    cambiarEjeY("%0.0fMhz", 1e-6);
    cambiarEjeX("%0.0fus", 1e6);
    title(ventanas{i}{2});
  end
  
  ans = guardarImagen("img/comparacion-ventanas2.pdf");
#+end_src
#+results:
   [[file:img/comparacion-ventanas2.pdf]]


** Ejercicio 4

   La chirp está definida como:

   $$chirp(t) = e^{j \phi(t)}$$

   Donde $\phi(t)$ es la fase en función del tiempo.Como ya se mostró
   en el punto 2, la frecuencia instantánea
   $\left(\frac{\partial\phi}{\partial t}\right)$ de la chirp (figura
   \ref{fig-chirp-frecuencia-instantanea}) es

   $$f\_inst(t) = 2 k_1 t + k_2$$

   Donde $k_2$ es la frecuencia inicial y $2 k_1$ es el incremento de
   frecuencia por unidad de tiempo.

   #+LABEL: fig-chirp-frecuencia-instantanea
   #+CAPTION: Frecuencia instantánea de la chirp
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  t = 0:1/Fs:10e-6;
  plot(t,4e12*t-20e6, 'linewidth', 5);
  axis([0 t(end)]);
  cambiarEjeX("%0.0fus", 1e6);
  cambiarEjeY("%0.0fMhz", 1/1e6);
  grid();
  ans = guardarImagen("img/chirp-frecuencia-instantanea.pdf");
#+end_src
#+results:
[[file:img/chirp-frecuencia-instantanea.pdf]]


*** TODO ancho de banda formalmente

** Ejercicio 5

   #+LABEL: fig-espectros-modulador-ideal
   #+CAPTION: Espectro de las señales en las diferentes fases del modulador
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  
  MPM = 2; 
  
  subplot(511);
  original = [zeros(1,10*MPM) bartlett(50*MPM).' zeros(1,10*MPM)];
  plot(-length(original)/2+1:length(original)/2, original, 'linewidth', 4);
  axis([-length(original)/2+1 length(original)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();
  
  subplot(512);
  desplazado = [zeros(1,(175+50+20)*MPM) zeros(1,175*MPM) bartlett(50*MPM).' zeros(1,20*MPM)];
  plot(-length(desplazado)/2+1:length(desplazado)/2, desplazado, 'linewidth', 4);
  axis([-length(desplazado)/2+1 length(desplazado)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();
  
  subplot(513);
  parteReal = [zeros(1,20*MPM) bartlett(50*MPM).' zeros(1,175*MPM) zeros(1,175*MPM) bartlett(50*MPM).' zeros(1,20*MPM)];
  plot(-length(parteReal)/2+1:length(parteReal)/2, parteReal, 'linewidth', 4);
  axis([-length(parteReal)/2+1 length(parteReal)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();
  
  
  subplot(514);
  redesplazado = [zeros(1,1100*MPM - length(parteReal)/2) parteReal];
  redesplazado = [redesplazado(end:-1:1) redesplazado]
  plot(-length(redesplazado)/2+1:length(redesplazado)/2, redesplazado, 'linewidth', 4);
  axis([-length(redesplazado)/2+1 length(redesplazado)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();
  
  subplot(515);
  filtro = ones(1,length(redesplazado));
  filtro(80*MPM:end-80*MPM)=0;
  filtrado = redesplazado .* filtro;
  plot(-length(filtrado)/2+1:length(filtrado)/2, filtrado, 'linewidth', 4);
  axis([-length(filtrado)/2+1 length(filtrado)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();
  
  
  ans = guardarImagen("img/espectros-modulador-ideal.pdf");
#+end_src
#+results:
   [[file:img/espectros-modulador-ideal.pdf]]

** Ejercicio 6

   #+LABEL: fig-espectros-modulador-ideal
   #+CAPTION: Espectro de las señales en las diferentes fases del demodulador
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  MPM = 2; 


  subplot(511);
  entrada = triangulo(40,1300,3000,MPM) .+ triangulo(40,-1300,3000,MPM);
  plot(-length(entrada)/2+1:length(entrada)/2,entrada, 'linewidth', 4);
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();  
  
  subplot(512);
  por_coseno = triangulo(40,2400,5000,MPM) + triangulo(40,200,5000,MPM) + triangulo(40,-2400,5000,MPM) + triangulo(40,-200,5000,MPM);
  plot(-length(por_coseno)/2+1:length(por_coseno)/2,por_coseno, 'linewidth', 4);
  axis([-length(por_coseno)/2+1 length(por_coseno)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();  
  
  subplot(513);
  filtrado = triangulo(40,200,480,MPM) + triangulo(40,-200,480,MPM);
  plot(-length(filtrado)/2+1:length(filtrado)/2,filtrado, 'linewidth', 4);
  axis([-length(filtrado)/2+1 length(filtrado)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();  
  
  subplot(514);
  por_coseno2 = 2*triangulo(40,0,880,MPM) + triangulo(40,-400,880,MPM) + triangulo(40,400,880,MPM);
  plot(-length(por_coseno2)/2+1:length(por_coseno2)/2,por_coseno2, 'linewidth', 4);
  axis([-length(por_coseno2)/2+1 length(por_coseno2)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();  
  
  subplot(515);
  ultimo = 2*triangulo(40,0,80,MPM);
  plot(-length(ultimo)/2+1:length(ultimo)/2,ultimo, 'linewidth', 4);
  axis([-length(ultimo)/2+1 length(ultimo)/2])
  cambiarEjeX("%0.0fMhz", 1/MPM);
  grid();  
  
  ans = guardarImagen("img/espectros-demodulador-ideal.pdf");
#+end_src
#+results:
   [[file:img/espectros-demodulador-ideal.pdf]]

** Ejercicio 7
   Las señales $I(t)$ y $Q(t)$, no son mas que las pertes real e
   imaginaria de la chirp emitida por el SARAT. El modulador lo que
   hace es desplazar el espectro de la chirp hasta los 1300Mhz (la
   modula) y luego la emite. Esta señal es reflejada por el suelo y
   vuelve al radar. Como estamos considerando que la señal al viajar
   hasta el suelo, rebotar y volver está pasando por un sistema LTI
   que solo introduce un retardo o un cambio de fase, la señal que
   recibe el radar es la misma que emitió, solo que con algún cambio
   de fase. Luego se pasa la señal a una banda intermedia de 200Mhz y
   por último es multiplicada por un coseno de 200Mhz en el caso de
   $I(t)$ o pos un seno de la misma frecuencia para el caso de $Q(t)$.

*** TODO redondeamelo

** Ejercicio 8
  Tanto el modulador como el demodulador son sistemas LTI. Como
  consideramos el mundo fuera del SARAT como un sistema LTI, entonces
  todo el sistema en su totalidad es LTI.


\newpage
* Parte digital
** Ejercicio 9
   #+LABEL: fig-datos-crudos
   #+CAPTION: Datos crudos del SARAT (subset)
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  colormap('gray');
  
  datos = cargarMatriz();
  
  tic;
    datos = 20*log10(abs(datos));
  toc;
  
  figure(1, 'visible', 'off');
    imagesc(datos);
  tic
  
  ans = guardarImagen("img/datos-crudos.pdf");
  toc
#+end_src
#+results:
   [[file:img/datos-crudos.pdf]]

   Podemos ver en la figura \ref{fig-datos-crudos}, que la ventana de
   recepción (ancho total de la imagen) dura 9000 muestras y que en
   cada línea (exceptuando las primeras 200) hay una región muy oscura
   al inicio de aproximadamente 350 muestras. Las primeras 200 lineas
   contienen solamente un muestreo de la chirp emitida por el
   SARAT. La duración de esta chirp es de 500 muestras o $10\mu
   s$. Entonces conociendo esta equivalencia entre cantidad de
   muestras y tiempo, podemos calcular que la ventana de adquisición
   dura $180 \mu s$. Si hacemos el cálculo teórico vemos que,
   primero, estamos tomando muestras a 50Mhz y que la cantidad de
   muestras horizontales es de 9000, entonces $\frac{9000}{50\,\,
   10^6} = 180\,\,10^{-6}$, y segundo para el rango $r_0 = 5659m$ y
   considerando que las ondas viajan a la velocidad de la luz y deben
   viajar de ida y vuelta, la onda tarda en viajar unos $37.75\mu s$.

** Ejercicio 10

   #+LABEL: fig-chirp-real-espectro
   #+CAPTION: Chirp real del SARAT (espectro)
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  chirp_real = cargarChirp();
  espectro = fftshift(abs(fft(chirp_real)));
  plot(-length(espectro)/2+1:length(espectro)/2,20*log10(espectro), 'linewidth', 4);
  axis([-length(espectro)/2+1 length(espectro)/2])
  cambiarEjeX("%.0fMhz",1/10);
  cambiarEjeY("%ddB", 1);
  grid();
  ans = guardarImagen("img/chirp-real-espectro.pdf");
#+end_src
#+results:
   [[file:img/chirp-real-espectro.pdf]]

   #+LABEL: fig-chirp-real
   #+CAPTION: Chirp real del SARAT
   #+ATTR_LaTeX: angle=-90,width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  datos = cargarMatriz();
  subplot(311);
  chirp_real = cargarChirp();
  plot(0:499,real(chirp_real),'linewidth', 4)
  title('Parte Real');
  subplot(312);
  plot(0:499,imag(chirp_real),'linewidth', 4)
  title('Parte Imaginaria');
  subplot(313);
  plot(0:499,angle(chirp_real),'linewidth', 4)
  title('Fase');
  axis([0 499 -pi pi])
  set(gca, 'ytick', [-pi -pi/2 0 pi/2 pi])
  set(gca, 'interpreter', 'tex');
  set(gca,'YTickLabel',{'-\pi' '-\pi/2' '0' '\pi/2' '\pi'}, 'interpreter', 'tex');
  ans = guardarImagen("img/chirp-real.pdf");
#+end_src
#+results:
   [[file:img/chirp-real.pdf]]

** Ejercicio 11

   #+LABEL: fig-modulo-espectro-rango
   #+CAPTION: Modulo del espectro en rango
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  datos_no_chirp = cargarMatrizCompleta();
  datos_no_chirp = datos_no_chirp(201:end,350:end);
  espectros = fftshift(abs(fft(datos_no_chirp, [] ,2))); #fft de cada fila
  espectro = sum(espectros,1)/rows(datos_no_chirp);
  plot(-length(espectro)/2+1:length(espectro)/2, 20*log10(espectro), 'linewidth', 4)
  
  axis([-length(espectro)/2+1 length(espectro)/2])
  
  cambiarEjeY("%ddB", 1);
  cambiarEjeX("%0.0fMhz", (Fs/2)/(length(espectro)/2) * 1e-6);
  
  grid();
  ans = guardarImagen("img/espectro-rango.pdf");
#+end_src
#+results:
   [[file:img/espectro-rango.pdf]]

   #+LABEL: fig-modulo-espectro-azimuth
   #+CAPTION: Modulo del espectro en azimuth
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  datos_no_chirp = cargarMatrizCompleta();
  datos_no_chirp = datos_no_chirp(201:end,350:end);
  espectros = fftshift(abs(fft(datos_no_chirp, [] ,1))); #fft de cada columna
  espectro = sum(espectros,2)/columns(datos_no_chirp);
  plot(-length(espectro)/2+1:length(espectro)/2, 20*log10(espectro), 'linewidth', 4)

  axis([-length(espectro)/2+1 length(espectro)/2])
  cambiarEjeY("%ddB", 1);
  cambiarEjeX("%0.0fHz", (PRF/2)/(length(espectro)/2));
  
  grid();
  ans = guardarImagen("img/espectro-azimuth.pdf");
#+end_src
#+results:
   [[file:img/espectro-azimuth.pdf]]

** Ejercicio 12

   #+LABEL: fig-modulo-espectro-azimuth-medio-prf
   #+CAPTION: Modulo del espectro en azimuth (medio PRF)
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  datos_no_chirp = cargarMatrizCompleta();
  datos_no_chirp = datos_no_chirp(201:end,350:end);
  datos_no_chirp = datos_no_chirp(1:2:end,:);
  espectros = fftshift(abs(fft(datos_no_chirp, [] ,1))); #fft de cada columna
  espectro = sum(espectros,2)/columns(datos_no_chirp);
  plot(-length(espectro)/2+1:length(espectro)/2, 20*log10(espectro), 'linewidth', 4)
  
  axis([-length(espectro)/2+1 length(espectro)/2])
  
  cambiarEjeY("%ddB", 1);
  cambiarEjeX("%0.0fHz", (PRF/4)/(length(espectro)/2));
  
  grid();
  ans = guardarImagen("img/espectro-azimuth-medio-prf.pdf");
#+end_src
#+results:
   [[file:img/espectro-azimuth-medio-prf.pdf]]


\newpage
* Compresión del pulso
** Ejercicio 13

   
   La correlación no es una operación conmutativa. La relación entre
   la correlación de dos funciones con su transformada de Fourier es
   la siguiente:
#+BEGIN_LATEX
  \begin{eqnarray*}
    {\mathcal F}| x[n] \star y[n]|(\Omega) &=& \sum_{n=-\infty}^{\infty} x[n] \star y[n] e^{-j\Omega n} \\
    &=& \sum_{n=-\infty}^{\infty} \sum_{k=-\infty}^{\infty} x[k] y^*[k-n] e^{-j\Omega n} \\
    &=& \sum_{k=-\infty}^{\infty} x[k] \sum_{n=-\infty}^{\infty} y^*[k-n] e^{-j\Omega n} \\
    &=& \sum_{k=-\infty}^{\infty} x[k] Y^*(\Omega) e^{-j\Omega k} \\
    &=& \sum_{k=-\infty}^{\infty} x[k]  e^{-j\Omega k}  Y^*(\Omega) \\
    &=& X(\Omega)  Y^*(\Omega)
  \end{eqnarray*}
  
#+END_LATEX

*** TODO explicar la relación con la convolución. Contraejemplo de conmutatividad


** Ejercicio 14

   #+LABEL: fig-simulacion-autocorrelacion
   #+CAPTION: Autocorrelación de la chirp del SARAT
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  chirp = cargarChirp();
  grid();
  fft_chirp = fftshift(fft(chirp,length(chirp)*3));
  correlacion = ifft(fft_chirp .* conj(fft_chirp));
  correlacion = [correlacion correlacion];
  plot(-length(correlacion)/2+1:length(correlacion)/2, abs(correlacion),'linewidth', 4);
  cambiarEjeX("¿%0.0f?",1);
  ans = guardarImagen("img/simulacion-autocorrelacion.pdf");
#+end_src
#+results:
   [[file:img/simulacion-autocorrelacion.pdf]]

\newpage   
* Compresión en rango
** Ejercicio 17
   #+LABEL: fig-compresion-en-rango
   #+CAPTION: Compresion en rango
   #+ATTR_LaTeX: width=0.9\columnwidth placement=[H]
#+begin_src octave :exports results :results file
  chirp = cargarChirp();
  datos = cargarMatriz();
  datos_no_chirp = datos(201:end,350:end);
  
  factor = 1;
  
  fft_chirp = fft(chirp,columns(datos_no_chirp)*factor);
  
  fft_datos = conj(fft(datos_no_chirp,columns(datos_no_chirp)*factor,2));
  
  clear compresion;
  tic
  for i = 1:rows(fft_datos)
    compresion(i,:) = ifft(fft_chirp .* fft_datos(i,:));
  end
  toc
  
  imagesc(20*log10(abs(compresion)));
  
  ans = guardarImagen("img/compresion-en-rango.pdf");
#+end_src
#+results:
   [[file:img/compresion-en-rango.pdf]]

\newpage
* Compresión en azimuth
\newpage
* Algoritmo de compresión
